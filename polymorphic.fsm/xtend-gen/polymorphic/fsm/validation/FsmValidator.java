/**
 * generated by Xtext 2.13.0
 */
package polymorphic.fsm.validation;

import java.util.function.Consumer;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.DijkstraShortestPath;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import polymorphic.fsm.fsm.Constraint;
import polymorphic.fsm.fsm.FsmPackage;
import polymorphic.fsm.fsm.Language;
import polymorphic.fsm.fsm.Machine;
import polymorphic.fsm.fsm.Model;
import polymorphic.fsm.fsm.Transition;
import polymorphic.fsm.generator.GeneratorCollection;
import polymorphic.fsm.validation.AbstractFsmValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class FsmValidator extends AbstractFsmValidator {
  public final String FINAL_STATE_UNREACHABLE = "FINAL_STATE_UNREACHABLE";
  
  public final String DEAD_STATE = "DEAD_STATE";
  
  public final String NO_INITIALS_STATE = "NO_INITIALS_STATE";
  
  public final String TOO_MANY_INITIAL_STATE = "TOO_MANY_INITIAL_STATE";
  
  public final static String LANGUAGE_CONSTRAINTS_ERROR = "LANGUAGE_CONSTRAINTS_ERROR";
  
  public final static String LANGUAGE_DOES_NOT_EXIST = "LANGUAGE_DOES_NOT_EXIST";
  
  public final static GeneratorCollection generators = new GeneratorCollection();
  
  @Check
  public void matchConstraints(final Language language) {
    final Function1<Constraint, Boolean> _function = (Constraint it) -> {
      boolean _xblockexpression = false;
      {
        final Boolean prop = FsmValidator.generators.getMap().get(language.getName()).properties().get(it.getName());
        _xblockexpression = (!((prop == null) || (it.isTrue() == (prop).booleanValue())));
      }
      return Boolean.valueOf(_xblockexpression);
    };
    final Function1<Constraint, String> _function_1 = (Constraint it) -> {
      return it.getName();
    };
    final Iterable<String> names = IterableExtensions.<Constraint, String>map(IterableExtensions.<Constraint>filter(EcoreUtil2.<Model>getContainerOfType(language, Model.class).getConstraints(), _function), _function_1);
    boolean _isEmpty = IterableExtensions.isEmpty(names);
    boolean _not = (!_isEmpty);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      String _name = language.getName();
      _builder.append(_name);
      _builder.append(" does not conform to rules ");
      String _join = IterableExtensions.join(names, ", ");
      _builder.append(_join);
      this.error(_builder.toString(), 
        FsmPackage.eINSTANCE.getLanguage_Name(), FsmValidator.LANGUAGE_CONSTRAINTS_ERROR);
    }
  }
  
  @Check
  public void checkLanguageExists(final Language language) {
    boolean _containsKey = FsmValidator.generators.getMap().containsKey(language.getName());
    boolean _not = (!_containsKey);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Language ");
      String _name = language.getName();
      _builder.append(_name);
      _builder.append(" does not exist.");
      this.error(_builder.toString(), language, FsmPackage.eINSTANCE.getLanguage_Name(), 
        FsmValidator.LANGUAGE_DOES_NOT_EXIST, language.getName());
    }
  }
  
  @Check
  public void reachableEndpoint(final polymorphic.fsm.fsm.State state) {
    boolean _isInitial = state.isInitial();
    boolean _not = (!_isInitial);
    if (_not) {
      final Machine machine = EcoreUtil2.<Machine>getContainerOfType(state, Machine.class);
      final DefaultDirectedGraph<polymorphic.fsm.fsm.State, DefaultEdge> graph = new DefaultDirectedGraph<polymorphic.fsm.fsm.State, DefaultEdge>(DefaultEdge.class);
      final Consumer<polymorphic.fsm.fsm.State> _function = (polymorphic.fsm.fsm.State it) -> {
        graph.addVertex(it);
      };
      machine.getStates().forEach(_function);
      final Consumer<Transition> _function_1 = (Transition it) -> {
        graph.addEdge(it.getFrom(), it.getTo());
      };
      machine.getTransitions().forEach(_function_1);
      final DijkstraShortestPath<polymorphic.fsm.fsm.State, DefaultEdge> dijkstra = new DijkstraShortestPath<polymorphic.fsm.fsm.State, DefaultEdge>(graph);
      final Function1<polymorphic.fsm.fsm.State, Boolean> _function_2 = (polymorphic.fsm.fsm.State it) -> {
        return Boolean.valueOf(it.isInitial());
      };
      final Function1<polymorphic.fsm.fsm.State, Boolean> _function_3 = (polymorphic.fsm.fsm.State it) -> {
        GraphPath<polymorphic.fsm.fsm.State, DefaultEdge> _path = dijkstra.getPath(it, state);
        return Boolean.valueOf((_path != null));
      };
      boolean _exists = IterableExtensions.<polymorphic.fsm.fsm.State>exists(IterableExtensions.<polymorphic.fsm.fsm.State>filter(machine.getStates(), _function_2), _function_3);
      boolean _not_1 = (!_exists);
      if (_not_1) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("State ");
        String _name = state.getName();
        _builder.append(_name);
        _builder.append(" cannot be reached");
        this.error(_builder.toString(), state, FsmPackage.Literals.STATE__NAME, 
          this.FINAL_STATE_UNREACHABLE);
      }
    }
  }
  
  @Check
  public void deadState(final polymorphic.fsm.fsm.State state) {
    boolean _isFinal = state.isFinal();
    boolean _not = (!_isFinal);
    if (_not) {
      final Machine machine = EcoreUtil2.<Machine>getContainerOfType(state, Machine.class);
      final DefaultDirectedGraph<polymorphic.fsm.fsm.State, DefaultEdge> graph = new DefaultDirectedGraph<polymorphic.fsm.fsm.State, DefaultEdge>(DefaultEdge.class);
      final Consumer<polymorphic.fsm.fsm.State> _function = (polymorphic.fsm.fsm.State it) -> {
        graph.addVertex(it);
      };
      machine.getStates().forEach(_function);
      final Consumer<Transition> _function_1 = (Transition it) -> {
        graph.addEdge(it.getFrom(), it.getTo());
      };
      machine.getTransitions().forEach(_function_1);
      final DijkstraShortestPath<polymorphic.fsm.fsm.State, DefaultEdge> dijkstra = new DijkstraShortestPath<polymorphic.fsm.fsm.State, DefaultEdge>(graph);
      final Function1<polymorphic.fsm.fsm.State, Boolean> _function_2 = (polymorphic.fsm.fsm.State it) -> {
        return Boolean.valueOf(it.isFinal());
      };
      final Function1<polymorphic.fsm.fsm.State, Boolean> _function_3 = (polymorphic.fsm.fsm.State it) -> {
        GraphPath<polymorphic.fsm.fsm.State, DefaultEdge> _path = dijkstra.getPath(state, it);
        return Boolean.valueOf((_path != null));
      };
      boolean _exists = IterableExtensions.<polymorphic.fsm.fsm.State>exists(IterableExtensions.<polymorphic.fsm.fsm.State>filter(machine.getStates(), _function_2), _function_3);
      boolean _not_1 = (!_exists);
      if (_not_1) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("State ");
        String _name = state.getName();
        _builder.append(_name);
        _builder.append(" is dead");
        this.error(_builder.toString(), state, FsmPackage.Literals.STATE__NAME, this.DEAD_STATE);
      }
    }
  }
  
  @Check
  public void initialStateExists(final Machine machine) {
    final Function1<polymorphic.fsm.fsm.State, Boolean> _function = (polymorphic.fsm.fsm.State it) -> {
      return Boolean.valueOf(it.isInitial());
    };
    boolean _exists = IterableExtensions.<polymorphic.fsm.fsm.State>exists(machine.getStates(), _function);
    boolean _not = (!_exists);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("No initial state");
      this.error(_builder.toString(), machine, FsmPackage.Literals.MACHINE__STATES, this.NO_INITIALS_STATE);
    }
  }
  
  @Check
  public void initialStateSingle(final Machine machine) {
    final Function1<polymorphic.fsm.fsm.State, Boolean> _function = (polymorphic.fsm.fsm.State it) -> {
      return Boolean.valueOf(it.isInitial());
    };
    final Iterable<polymorphic.fsm.fsm.State> is = IterableExtensions.<polymorphic.fsm.fsm.State>filter(machine.getStates(), _function);
    int _length = ((Object[])Conversions.unwrapArray(is, Object.class)).length;
    boolean _greaterThan = (_length > 1);
    if (_greaterThan) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Too many initial states (");
      {
        boolean _hasElements = false;
        for(final polymorphic.fsm.fsm.State i : is) {
          if (!_hasElements) {
            _hasElements = true;
          } else {
            _builder.appendImmediate(", ", "");
          }
          String _name = i.getName();
          _builder.append(_name);
        }
      }
      _builder.append(")");
      this.error(_builder.toString(), machine, FsmPackage.Literals.MACHINE__STATES, this.TOO_MANY_INITIAL_STATE);
    }
  }
}
