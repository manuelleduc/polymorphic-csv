/*
 * generated by Xtext 2.13.0
 */
package polymorphic.fsm.validation

import org.eclipse.xtext.validation.Check
import org.jgrapht.alg.shortestpath.DijkstraShortestPath
import org.jgrapht.graph.DefaultDirectedGraph
import org.jgrapht.graph.DefaultEdge
import polymorphic.fsm.fsm.FsmPackage
import polymorphic.fsm.fsm.Language
import polymorphic.fsm.fsm.Machine
import polymorphic.fsm.fsm.Model
import polymorphic.fsm.generator.GeneratorCollection

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FsmValidator extends AbstractFsmValidator {

	public val FINAL_STATE_UNREACHABLE = "FINAL_STATE_UNREACHABLE"
	public val DEAD_STATE = "DEAD_STATE"
	public val NO_INITIALS_STATE = "NO_INITIALS_STATE"
	public val TOO_MANY_INITIAL_STATE = "TOO_MANY_INITIAL_STATE"
	public static val LANGUAGE_CONSTRAINTS_ERROR = "LANGUAGE_CONSTRAINTS_ERROR"
	public static val LANGUAGE_DOES_NOT_EXIST = "LANGUAGE_DOES_NOT_EXIST"
	
	public static val generators = new GeneratorCollection
	
	@Check
	def matchConstraints(Language language) {
		val names = getContainerOfType(language, Model).constraints.filter [
			val prop = generators.map.get(language.name).properties.get(it.name)
			!(prop === null || it.^true == prop)
		].map[it.name]

		if (!names.empty) {
			error('''«language.name» does not conform to rules «names.join(', ')»''',
				FsmPackage::eINSTANCE.language_Name, LANGUAGE_CONSTRAINTS_ERROR)
		}
	}
	
	@Check
	def checkLanguageExists(Language language) {
		if(!generators.map.containsKey(language.name)) {
			error('''Language «language.name» does not exist.''', language, FsmPackage::eINSTANCE.language_Name,
				LANGUAGE_DOES_NOT_EXIST, language.name)
		}
	}

	@Check
	def reachableEndpoint(polymorphic.fsm.fsm.State state) {

		if (!state.isInitial) {
			val machine = state.getContainerOfType(Machine)
			val graph = new DefaultDirectedGraph<polymorphic.fsm.fsm.State, DefaultEdge>(DefaultEdge)

			machine.states.forEach[graph.addVertex(it)]
			machine.transitions.forEach[graph.addEdge(it.from, it.to)]

			val dijkstra = new DijkstraShortestPath(graph)

			if (!machine.states.filter[it.initial].exists[dijkstra.getPath(it, state) !== null]) {
				error('''State «state.name» cannot be reached''', state, FsmPackage.Literals.STATE__NAME,
					FINAL_STATE_UNREACHABLE)
			}

		}
	}

	@Check
	def deadState(polymorphic.fsm.fsm.State state) {
		if (!state.isFinal) {
			val machine = state.getContainerOfType(Machine)
			val graph = new DefaultDirectedGraph<polymorphic.fsm.fsm.State, DefaultEdge>(DefaultEdge)

			machine.states.forEach[graph.addVertex(it)]
			machine.transitions.forEach[graph.addEdge(it.from, it.to)]

			val dijkstra = new DijkstraShortestPath(graph)

			if (!machine.states.filter[it.final].exists[dijkstra.getPath(state, it) !== null]) {
				error('''State «state.name» is dead''', state, FsmPackage.Literals.STATE__NAME, DEAD_STATE)
			}

		}
	}

	@Check
	def initialStateExists(Machine machine) {
		if (!machine.states.exists[it.initial]) {
			error('''No initial state''', machine, FsmPackage.Literals.MACHINE__STATES, NO_INITIALS_STATE)
		}
	}

	@Check
	def initialStateSingle(Machine machine) {
		val is = machine.states.filter[it.initial]
		if (is.length > 1) {
			error('''Too many initial states («FOR i: is SEPARATOR ', '»«i.name»«ENDFOR»)''', machine, FsmPackage.Literals.MACHINE__STATES, TOO_MANY_INITIAL_STATE)
		}
	}

}
